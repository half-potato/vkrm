/******************************************************************************
 * Copyright (c) 2011, Duane Merrill.  All rights reserved.
 * Copyright (c) 2011-2025, NVIDIA CORPORATION.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the NVIDIA CORPORATION nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************/


#pragma once

#include <cub/config.cuh>

#if defined(_CCCL_IMPLICIT_SYSTEM_HEADER_GCC)
#  pragma GCC system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_CLANG)
#  pragma clang system_header
#elif defined(_CCCL_IMPLICIT_SYSTEM_HEADER_MSVC)
#  pragma system_header
#endif 
#include <cub/detail/choose_offset.cuh>
#include <cub/device/dispatch/dispatch_radix_sort.cuh>

#include <cuda/std/type_traits>

CUB_NAMESPACE_BEGIN

struct DeviceRadixSort
{
private:
    template <SortOrder Order, typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
        CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
        ::cuda::std::false_type,
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        bool is_overwrite_okay,
    DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        NumItemsT num_items,
        DecomposerT decomposer,
        int begin_bit,
        int end_bit,
        cudaStream_t stream);

    template <SortOrder Order, typename KeyT, typename ValueT, typename OffsetT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
        ::cuda::std::true_type,
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        bool is_overwrite_okay,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        OffsetT num_items,
        DecomposerT decomposer,
        int begin_bit,
        int end_bit,
        cudaStream_t stream)
    {
        return DispatchRadixSort<Order, KeyT, ValueT, OffsetT, DecomposerT>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            static_cast<OffsetT>(num_items),
            begin_bit,
            end_bit,
            is_overwrite_okay,
            stream,
            decomposer);
    }

    template <SortOrder Order, typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
        ::cuda::std::false_type,
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        bool is_overwrite_okay,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        NumItemsT num_items,
        DecomposerT decomposer,
        cudaStream_t stream);

    template <SortOrder Order, typename KeyT, typename ValueT, typename OffsetT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static cudaError_t custom_radix_sort(
        ::cuda::std::true_type,
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        bool is_overwrite_okay,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        OffsetT num_items,
        DecomposerT decomposer,
        cudaStream_t stream)
    {
        constexpr int begin_bit = 0;
        const int end_bit       = detail::radix::traits_t<KeyT>::default_end_bit(decomposer);

        return DeviceRadixSort::custom_radix_sort<Order>(
            ::cuda::std::true_type{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            num_items,
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    _CCCL_HOST_DEVICE static constexpr auto GetName() -> const char*
    {
        return "cub::DeviceRadixSort";
    }

    public:

    template <typename KeyT, typename ValueT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        const ValueT* d_values_in,
        ValueT* d_values_out,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
        using OffsetT = detail::choose_offset_t<NumItemsT>;


        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

        return DispatchRadixSort<SortOrder::Ascending, KeyT, ValueT, OffsetT>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            static_cast<OffsetT>(num_items),
            begin_bit,
            end_bit,
            is_overwrite_okay,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairs(void* d_temp_storage,
              size_t& temp_storage_bytes,
              const KeyT* d_keys_in,
              KeyT* d_keys_out,
              const ValueT* d_values_in,
              ValueT* d_values_out,
              NumItemsT num_items,
              DecomposerT decomposer,
              int begin_bit,
              int end_bit,
              cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairs(void* d_temp_storage,
              size_t& temp_storage_bytes,
              const KeyT* d_keys_in,
              KeyT* d_keys_out,
              const ValueT* d_values_in,
              ValueT* d_values_out,
              NumItemsT num_items,
              DecomposerT decomposer,
              cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());
        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortPairs(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = true;

        return DispatchRadixSort<SortOrder::Ascending, KeyT, ValueT, OffsetT>::Dispatch(
            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairs(void* d_temp_storage,
              size_t& temp_storage_bytes,
              DoubleBuffer<KeyT>& d_keys,
              DoubleBuffer<ValueT>& d_values,
              NumItemsT num_items,
              DecomposerT decomposer,
              cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairs(void* d_temp_storage,
              size_t& temp_storage_bytes,
              DoubleBuffer<KeyT>& d_keys,
              DoubleBuffer<ValueT>& d_values,
              NumItemsT num_items,
              DecomposerT decomposer,
              int begin_bit,
              int end_bit,
              cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        const ValueT* d_values_in,
        ValueT* d_values_out,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

        return DispatchRadixSort<SortOrder::Descending, KeyT, ValueT, OffsetT>::Dispatch(
            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairsDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        const ValueT* d_values_in,
        ValueT* d_values_out,
        NumItemsT num_items,
        DecomposerT decomposer,
        int begin_bit,
        int end_bit,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairsDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        const ValueT* d_values_in,
        ValueT* d_values_out,
        NumItemsT num_items,
        DecomposerT decomposer,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<ValueT> d_values(const_cast<ValueT*>(d_values_in), d_values_out);

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortPairsDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = true;

        return DispatchRadixSort<SortOrder::Descending, KeyT, ValueT, OffsetT>::Dispatch(
            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairsDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        NumItemsT num_items,
        DecomposerT decomposer,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename ValueT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortPairsDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        DoubleBuffer<ValueT>& d_values,
        NumItemsT num_items,
        DecomposerT decomposer,
        int begin_bit,
        int end_bit,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }


    template <typename KeyT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<NullType> d_values;

        return DispatchRadixSort<SortOrder::Ascending, KeyT, NullType, OffsetT>::Dispatch(
            d_temp_storage,
            temp_storage_bytes,
            d_keys,
            d_values,
            static_cast<OffsetT>(num_items),
            begin_bit,
            end_bit,
            is_overwrite_okay,
            stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeys(void* d_temp_storage,
             size_t& temp_storage_bytes,
             const KeyT* d_keys_in,
             KeyT* d_keys_out,
             NumItemsT num_items,
             DecomposerT decomposer,
             int begin_bit,
             int end_bit,
             cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeys(void* d_temp_storage,
             size_t& temp_storage_bytes,
             const KeyT* d_keys_in,
             KeyT* d_keys_out,
             NumItemsT num_items,
             DecomposerT decomposer,
             cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortKeys(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = true;

        DoubleBuffer<NullType> d_values;

        return DispatchRadixSort<SortOrder::Ascending, KeyT, NullType, OffsetT>::Dispatch(
            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeys(void* d_temp_storage,
             size_t& temp_storage_bytes,
             DoubleBuffer<KeyT>& d_keys,
             NumItemsT num_items,
             DecomposerT decomposer,
             cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeys(void* d_temp_storage,
             size_t& temp_storage_bytes,
             DoubleBuffer<KeyT>& d_keys,
             NumItemsT num_items,
             DecomposerT decomposer,
             int begin_bit,
             int end_bit,
             cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Ascending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    template <typename KeyT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<NullType> d_values;

        return DispatchRadixSort<SortOrder::Descending, KeyT, NullType, OffsetT>::Dispatch(
            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeysDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        NumItemsT num_items,
        DecomposerT decomposer,
        int begin_bit,
        int end_bit,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeysDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        const KeyT* d_keys_in,
        KeyT* d_keys_out,
        NumItemsT num_items,
        DecomposerT decomposer,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = false;
        DoubleBuffer<KeyT> d_keys(const_cast<KeyT*>(d_keys_in), d_keys_out);
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename NumItemsT>
    CUB_RUNTIME_FUNCTION static cudaError_t SortKeysDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        NumItemsT num_items,
        int begin_bit       = 0,
        int end_bit         = sizeof(KeyT) * 8,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using OffsetT = detail::choose_offset_t<NumItemsT>;

        constexpr bool is_overwrite_okay = true;

        DoubleBuffer<NullType> d_values;

        return DispatchRadixSort<SortOrder::Descending, KeyT, NullType, OffsetT>::Dispatch(
            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, is_overwrite_okay, stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeysDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        NumItemsT num_items,
        DecomposerT decomposer,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            stream);
    }

    template <typename KeyT, typename NumItemsT, typename DecomposerT>
    CUB_RUNTIME_FUNCTION static     ::cuda::std::enable_if_t<       !::cuda::std::is_convertible_v<DecomposerT, int>,       cudaError_t>
    SortKeysDescending(
        void* d_temp_storage,
        size_t& temp_storage_bytes,
        DoubleBuffer<KeyT>& d_keys,
        NumItemsT num_items,
        DecomposerT decomposer,
        int begin_bit,
        int end_bit,
        cudaStream_t stream = 0)
    {
        _CCCL_NVTX_RANGE_SCOPE_IF(d_temp_storage, GetName());

        using offset_t           = detail::choose_offset_t<NumItemsT>;
        using decomposer_check_t = detail::radix::decomposer_check_t<KeyT, DecomposerT>;

        static_assert(decomposer_check_t::value,
        "DecomposerT must be a callable object returning a tuple of references to "
        "arithmetic types");

        constexpr bool is_overwrite_okay = true;
        DoubleBuffer<NullType> d_values;

        return DeviceRadixSort::custom_radix_sort<SortOrder::Descending>(
            decomposer_check_t{},
            d_temp_storage,
            temp_storage_bytes,
            is_overwrite_okay,
            d_keys,
            d_values,
            static_cast<offset_t>(num_items),
            decomposer,
            begin_bit,
            end_bit,
            stream);
    }

};

CUB_NAMESPACE_END
